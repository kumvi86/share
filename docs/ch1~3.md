# 문제해결과 프로그래밍 대회
* 프로그래머는 다양한 종류가 있지만, 어떤 분야를 막론하고 문제해결능력은 필수적이다
* 그러나 실무에서는 문제해결 자체보다 전체 시스템의 구조에 영향을 받는 경우가 많으므로 문제해결 능력을 기르는 것은 어렵다
* 이러한 문제해결 능력은 추상적인 기술이므로 훈련하기가 어려운데 가장 좋은 방법은 프로그래밍 대회에 자주 참가하는 것이다
* 프로그래밍 대회가 좋은 이유
  * 그래픽 인터페이스가 없으므로 문제해결에만 집중할 수 있음
  * CPU를 사용하는 계산집중적 문제이기 때문에 알고리즘과 자료구조를 직접 사용해 볼 수 있음
  * 정답과 오답의 구분이 명화가기 때문에 객관적인 평가가 가능
  * 자신이 코딩한 프로그램의 효율성을 직접 체험
  * 실무에서는 알고리즘보다 설계가 중요한 경우가 많기 때문에 그보다 작은 부분에 집중 할 수 있음
  * 대회라는 것은 곧 경쟁이지만 실패하더라도 고수의 코드를 보고 배울 수 있음
* 유명한 프로그래밍 대회
  * 한국정보올림피아드
  * [알고스팟](http:/algospot.com)
  * [ACM-ICPC](http://www.acmicpc.net)
  * [TopCoder](http://www.topcoder.com/tc)
  * 구글코드잼
  * [코드포스](http://codeforce.com)
  * [바야돌리드 대학교](http://uva.onlinejudge.org)
  * [프로젝트 오일러](http://projecteuler.net)
  * [SPOJ Online Judge](http://spoj.pl)
* 추천서적
  * Introduction to Algorithms : 전 세계 전산학과 알고리즘, 자료구조의 교과서
  * Programming Challenges : 바야돌리드 대학교의 문제와 문제풀이 일부, 좋은 입문서
  * The Art of Computer Programming : 알고리즘 부야의 가장 권이 있는 책, MMIX 어셈블리를 사용하기 때문에 진입장벽 있음
  * 프로그래밍 콘세스트 챌린징 : 일본의 프로그래밍 고수들이 쓴 책으로 실용적이고 다양한 테크닉
* 문제 - 록 페스티벌 (난이도:하, 문제ID:FESTIVAL)
  * 상황
    * 공연장을 빌려서 록 페스티발을 개최하려 함
    * 이 공연은 여러 날 동안 진행됨
    * 하루에 한 팀의 밴드가 콘스트를 함
    * 몇 개의 밴드를 섭외할지는 결정하지 않았지만, L개의 팀은 이미 섭외함
    * 따라서 페스티벌은 최소 L일 이상 지속됨
    * N일간의 공연장 대여비용을 알고 있다가 할 때, **L일 이상 연속해서 대여하는 평균비용을 최소화하려면** 어떻게 빌려야 하나?
  * 입력의 첫 줄 - 테스트 케이스의 수 C(C<=100)
  * 각 테스트케이스의 첫번째 줄
    * 공연장을 대여할 수 있는 날들의 수 N(1<=N<=1000)
    * 이미 섭외한 공연팀의 수 L(1<=L<=1000, L<=N)
  * 각 테스트케이스의 두번째 줄
    * N개의 공연장 연속적인 대여 비용
  ```
  2
  6 3
  1 2 3 1 2 3
  6 2
  1 2 3 1 2 3
  ```
  * 정답 출력
    * 첫번째 테스트케이스 : 1.75 = (1+2+3+1) / 4
    * 두번째 테스트케이스 : 1.50 = (1+2) / 2

# 문제 해결 개관
* 무작정 문제를 많이 푼다고 좋은 것은 아님
* 자신의 문제 해결과정을 분석하는 것이 필요
* 이 장에서는 문제 해결과정을 여러 단계로 나눠보고 각 단계별로 설명
* 6단계
  * 1단계: 문제를 읽고 이해하기
    * 위의 예제에서 볼 수 있듯이 문제를 이해하는 것 자체가 어렵고, 초심자들은 문제를 대충 이해하는 경우가 많다
    * 문제를 대충 이해하면 나머지 5단계를 아무리 잘해도 의미가 없다
  * 2단계: 재정의와 추성화
    * 문제를 익숙한 용어로 재정의 하는 것이다
    * 문제는 대부분 현실 세계의 개념을 서술하는 것이기 때문에 이것을 컴퓨터 프로그래밍과 연결할 수 있도록 해야한다
    * 이러한 과정을 추상화라고 하며, 잘못된 추상화는 문제의 해결방법을 오히려 어렵게 만들수도 있다
  * 3단계: 전략수립
    * 여기서 문제해결을 위한 알고리즘과 자료구조를 선택한다
    * 이미 알고있는 알고리즘과 자료구조를 통해 해결할 수 있다면 베스트이지만, 그렇지 않은 경우 여기서 가장 많은 시간을 소비하게 된다
  * 4단계: 전략검증
    * 전략을 세웠다고 해서 바로 키보드를 잡으면 안 된다
    * 선택한 알고리즘과 자료구조를 통해 문제를 주어진 시간과 메모리 용량을 통해 해결할 수 있는지 검증해야 한다
    * 그렇지 않은 경우, 3단계로 돌아가서 새로운 계획을 세운다
    * 4,5장에서는 이러한 알고리즘의 효율성과 정당성을 증명하는 전략을 배운다
  * 5단계: 전략수행(코딩)
    * 실제로 프로그래밍을 시작한다
    * 아무리 좋은 알고리즘과 자료구조를 찾았다고 해도 이를 구현할 수 없으면 아무런 의미가 없다
  * 6단계: 회고하기
    * 문제해결에 직접적인 연관은 없지만, 장기적으로 중요하다
    * 내가 해결한 과정을 돌아봐야만 유사한 문제에 대해 더 효율적인 알고리즘을 선택할 수 있다
    * 가장 좋은 방법은 문제를 해결한 코드와 접근방식을 기록으로 남겨두는 것이다
    * 맞추지 못한 경우, 오답원인도 꼭 기록해야 한다
    * 마지막으로 같은 문제를 해결한 다른사람의 코드를 봐야한다, 이를 통해 자신이 생각하지 못했던 통찰을 얻을 수 있다
    * 그래서 스터디나 인터넷을 통해 함께 공부하는 것이 중요하다
* 위의 6단계는 꼭 의식하지 않더라도 많은 문제를 풀다보면 자연스럽게 체득화 되며, 많은 프로그래밍 참가자들이 거쳐가는 과정이다
* 해결방법을 찾지 못했을 때
  * 위의 6단계를 통해서 문제를 풀지 못하는 경우가 있을 것이다
  * 물론 최대한 직접 고민하여 해결방법을 찾는 것이 중요하다
  * 다만, 너무 많은 시간을 허비하는 것도 좋지는 않으며 그럴 때는 다른 사람의 소스코드나 풀이를 참고한다
  * 단, 자신이 왜 그러한 풀이를 떠올리지 못했는지 돌아봐야 하며 해당 알고리즘, 자료구조, 풀이기법을 꼭 기록하자
  * 그래야만 유사한 문제를 봤을 때, 해당 기법이 떠오를 것이다
* 4단계: 전략수립을 위한 체계적인 접근방법 10가지
  * 

# 코딩과 디버깅에 관하여
