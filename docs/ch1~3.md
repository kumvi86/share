# 1징. 문제해결과 프로그래밍 대회
## 1.1 도입
* 프로그래머는 다양한 종류가 있지만, 어떤 분야를 막론하고 문제해결능력은 필수적이다
* 그러나 실무에서는 문제해결 자체보다 전체 시스템의 구조에 영향을 받는 경우가 많으므로 문제해결 능력을 기르는 것은 어렵다
* 이러한 문제해결 능력은 추상적인 기술이므로 훈련하기가 어려운데 가장 좋은 방법은 프로그래밍 대회에 자주 참가하는 것이다
## 1.2 프
* 프로그래밍 대회가 좋은 이유
  * 그래픽 인터페이스가 없으므로 문제해결에만 집중할 수 있음
  * CPU를 사용하는 계산집중적 문제이기 때문에 알고리즘과 자료구조를 직접 사용해 볼 수 있음
  * 정답과 오답의 구분이 명화가기 때문에 객관적인 평가가 가능
  * 자신이 코딩한 프로그램의 효율성을 직접 체험
  * 실무에서는 알고리즘보다 설계가 중요한 경우가 많기 때문에 그보다 작은 부분에 집중 할 수 있음
  * 대회라는 것은 곧 경쟁이지만 실패하더라도 고수의 코드를 보고 배울 수 있음
* 유명한 프로그래밍 대회
  * 한국정보올림피아드
  * [알고스팟](http:/algospot.com)
  * [ACM-ICPC](http://www.acmicpc.net)
  * [TopCoder](http://www.topcoder.com/tc)
  * 구글코드잼
  * [코드포스](http://codeforce.com)
  * [바야돌리드 대학교](http://uva.onlinejudge.org)
  * [프로젝트 오일러](http://projecteuler.net)
  * [SPOJ Online Judge](http://spoj.pl)
* 추천서적
  * Introduction to Algorithms : 전 세계 전산학과 알고리즘, 자료구조의 교과서
  * Programming Challenges : 바야돌리드 대학교의 문제와 문제풀이 일부, 좋은 입문서
  * The Art of Computer Programming : 알고리즘 부야의 가장 권이 있는 책, MMIX 어셈블리를 사용하기 때문에 진입장벽 있음
  * 프로그래밍 콘세스트 챌린징 : 일본의 프로그래밍 고수들이 쓴 책으로 실용적이고 다양한 테크닉
* 문제 - 록 페스티벌 (난이도:하, 문제ID:FESTIVAL)
  * 상황
    * 공연장을 빌려서 록 페스티발을 개최하려 함
    * 이 공연은 여러 날 동안 진행됨
    * 하루에 한 팀의 밴드가 콘스트를 함
    * 몇 개의 밴드를 섭외할지는 결정하지 않았지만, L개의 팀은 이미 섭외함
    * 따라서 페스티벌은 최소 L일 이상 지속됨
    * N일간의 공연장 대여비용을 알고 있다가 할 때, **L일 이상 연속해서 대여하는 평균비용을 최소화하려면** 어떻게 빌려야 하나?
  * 입력의 첫 줄 - 테스트 케이스의 수 C(C<=100)
  * 각 테스트케이스의 첫번째 줄
    * 공연장을 대여할 수 있는 날들의 수 N(1<=N<=1000)
    * 이미 섭외한 공연팀의 수 L(1<=L<=1000, L<=N)
  * 각 테스트케이스의 두번째 줄
    * N개의 공연장 연속적인 대여 비용
  ```
  2
  6 3
  1 2 3 1 2 3
  6 2
  1 2 3 1 2 3
  ```
  * 정답 출력
    * 첫번째 테스트케이스 : 1.75 = (1+2+3+1) / 4
    * 두번째 테스트케이스 : 1.50 = (1+2) / 2

# 2장. 문제 해결 개관
## 2.1 도입
* 무작정 문제를 많이 푼다고 좋은 것은 아님
* 자신의 문제 해결과정을 분석하는 것이 필요
* 이 장에서는 문제 해결과정을 여러 단계로 나눠보고 각 단계별로 설명
## 2.2 문제해결 과정
* 6단계
  * 1단계: 문제를 읽고 이해하기
    * 위의 예제에서 볼 수 있듯이 문제를 이해하는 것 자체가 어렵고, 초심자들은 문제를 대충 이해하는 경우가 많다
    * 문제를 대충 이해하면 나머지 5단계를 아무리 잘해도 의미가 없다
  * 2단계: 재정의와 추성화
    * 문제를 익숙한 용어로 재정의 하는 것이다
    * 문제는 대부분 현실 세계의 개념을 서술하는 것이기 때문에 이것을 컴퓨터 프로그래밍과 연결할 수 있도록 해야한다
    * 이러한 과정을 추상화라고 하며, 잘못된 추상화는 문제의 해결방법을 오히려 어렵게 만들수도 있다
  * 3단계: 전략수립
    * 여기서 문제해결을 위한 알고리즘과 자료구조를 선택한다
    * 이미 알고있는 알고리즘과 자료구조를 통해 해결할 수 있다면 베스트이지만, 그렇지 않은 경우 여기서 가장 많은 시간을 소비하게 된다
  * 4단계: 전략검증
    * 전략을 세웠다고 해서 바로 키보드를 잡으면 안 된다
    * 선택한 알고리즘과 자료구조를 통해 문제를 주어진 시간과 메모리 용량을 통해 해결할 수 있는지 검증해야 한다
    * 그렇지 않은 경우, 3단계로 돌아가서 새로운 계획을 세운다
    * 4,5장에서는 이러한 알고리즘의 효율성과 정당성을 증명하는 전략을 배운다
  * 5단계: 전략수행(코딩)
    * 실제로 프로그래밍을 시작한다
    * 아무리 좋은 알고리즘과 자료구조를 찾았다고 해도 이를 구현할 수 없으면 아무런 의미가 없다
  * 6단계: 회고하기
    * 문제해결에 직접적인 연관은 없지만, 장기적으로 중요하다
    * 내가 해결한 과정을 돌아봐야만 유사한 문제에 대해 더 효율적인 알고리즘을 선택할 수 있다
    * 가장 좋은 방법은 문제를 해결한 코드와 접근방식을 기록으로 남겨두는 것이다
    * 맞추지 못한 경우, 오답원인도 꼭 기록해야 한다
    * 마지막으로 같은 문제를 해결한 다른사람의 코드를 봐야한다, 이를 통해 자신이 생각하지 못했던 통찰을 얻을 수 있다
    * 그래서 스터디나 인터넷을 통해 함께 공부하는 것이 중요하다
* 위의 6단계는 꼭 의식하지 않더라도 많은 문제를 풀다보면 자연스럽게 체득화 되며, 많은 프로그래밍 참가자들이 거쳐가는 과정이다
* 해결방법을 찾지 못했을 때
  * 위의 6단계를 통해서 문제를 풀지 못하는 경우가 있을 것이다
  * 물론 최대한 직접 고민하여 해결방법을 찾는 것이 중요하다
  * 다만, 너무 많은 시간을 허비하는 것도 좋지는 않으며 그럴 때는 다른 사람의 소스코드나 풀이를 참고한다
  * 단, 자신이 왜 그러한 풀이를 떠올리지 못했는지 돌아봐야 하며 해당 알고리즘, 자료구조, 풀이기법을 꼭 기록하자
  * 그래야만 유사한 문제를 봤을 때, 해당 기법이 떠오를 것이다
## 2.3 문제해결 전략
* 전략수립을 위한 체계적인 접근방법 10가지
  * 전략수립이 막막한 경우가 많다
  * 이럴때는 문제해결을 위한 직관력을 키우는게 중요한데, 처음부터 직관력을 가질수는 없다
  * 직관력은 아래와 같은 방법을 통해 많은 문제를 해결하다 보면 발달하게 되며 아래 10가지는 이를 위한 좋은 시작점이다
    * 4-1단계: 비슷한 유형 떠올려보기
      * 어떤 문제의 유형에는 어떤 알고리즘을 사용한다라는 것이 연상되는 경우이다
      * 이를 위해서는 문제가 어떤 유형이고 이를 위한 해결법이 무엇인지를 체계적으로 공부해야 한다 이 책은 이러한 방법을 도와준다
      * (예) 문제유형-경우의 수, 해결법-동적계획법 / 문제유형-두 도시를 잇는 가장빠른 기차, 해결법-최단경로 알고리즘
    * 4-2단계: 단순한 방법으로 시작해보기
    * 4-3단계: 손으로 해보기
    * 4-4단계: 단순화하기
    * 4-5단계: 그림 그려보기
    * 4-6단계: 수식화해보기
    * 4-7단계: 분해해보기
    * 4-8단계: 뒤에서부터 생각하기
    * 4-9단계: 순서를 강제로 만들기
    * 4-10단계: 정규화된 답을 찾기

# 3장. 코딩과 디버깅에 관하여
## 3.1 도입: 코딩의 중요성을 간과하지 말라
* 2장에서 문제해결을 전략을 주로 다뤘으며 그 중에서 5단계: 전략수행(코딩) 은 역시 중요하다
* 문제해결만 된다면 스파게티 코드를 작성해도 되는 것이 아니다
* 코드가 간결하고 이해하기 쉬워야만 문제해결 과정에서 디버깅이 쉽고 실수를 줄일 수 있다
## 3.2 좋은 코드를 짜기 위한 원칙
* 좋은 코딩습관을 위한 규칙들은 아래와 같다
  * 규칙1: 간결한 코드를 작성하기
  * 규칙2: 적극적으로 코드 재사용하기
  * 규칙3: 표준 라이브러리 공부하기
  * 규칙4: 항상 같은 형태로 프로그램을 작성하기
  * 규칙5: 일관적이고 명로한 명명법 사용하기
  * 규칙6: 모든 자료를 정규화해서 저장하기
  * 규칙7: 코드와 데이터를 분리하기
* 각각에 대한 상세설명
  * 규칙1: 간결한 코드를 작성하기
    * 어떤 프로그래밍을 하더라도 주요한 원칙 중 하나이다
    * 프로그래밍 대회에서의 특징이라면 전역변수와 매크로를 사용하는 것도 어느정도 필요하다는 것이다
    * 왜냐하면 대부분의 경우, 코드의 길이가 길지 않고, 실수를 줄이는 것이 더 중요하기 때문이다
  * 규칙2: 적극적으로 코드 재사용하기
    * 이것도 어떤 프로그래밍을 하더라도 주요한 원칙 중 하나이다
    * 프로그래밍 대회에서의 특징이라면 SRP(Single Response Principle)이 적용되지 않는 경우가 많다
    * 실무에서는 한개의 클래스 또는 함수가 하나의 역할만 하도록 설계,구현하는 것이 일반적이지만,
    * 프로그래밍 대회에서는 그렇게 하면 시간제한도 있고, 재사용하기 어려운 경우가 많기 때문에 SRP는 일반적이지 않다
  * 규칙3: 표준 라이브러리 공부하기
    * 학교에서 숙제를 하듯이, 이미 구현된 알고리즘, 자료구조를 직접 구현하는 것은 낭비이다
    * 문자열, 동적배열, 스택, 큐, 리스트, 사전 등의 자료구조와 정령 등의 표준알고리즘, 즉 C++ STL 사용법을 반드시 알아두어야 한다
  * 규칙4: 항상 같은 형태로 프로그램을 작성하기
    * 프로그래밍 습관이 들쭉날쭉하면 실수하기 쉽고 디버깅에 긴 시간을 들이게 된다
    * 예를 들어, while/do-while 중 어떤것을 사용할지, 2차원 배열을 크기를 가로/세로 혹은 세로/가로 순서로 전달하는지 등은 일관성이 있어야 한다
  * 규칙5: 일관적이고 명료한 명명법 사용하기
    * 프로그래밍 대회의 경우, 실무적인 코딩과 다른 부분이 많지만 이것은 동일하게 적용된다
    * 예를 들어, 아래와 같은 함수는 무언가를 평가하는 것인데 어느경우에 참인지 알 수가 없다
    ```
    bool judge(int y, int x, int cy, int cx, int cr);
    ```
    * 아래와 같이 명명해야 실수하지 않는다
    ```
    bool isInsideCircle(int y, int x, int cy, int cx, int cr)
    ```
  * 규칙6: 모든 자료를 정규화해서 저장하기
    * 정규화는 어떤 자료를 입력받자마자 바로 수행해야 한다
    * 여기서 정규화라는 것은 아래와 같은 경우를 의미한다
    * 예1) 9/6 과 3/2 는 같은 값이므로 1가지로 통일하자
    * 예2) 2차원 평면에서 두 점의 각도를 구한다고 하면 -30도, 330도, 690도는 같은 값이므로 1가지로 통일하자
    * 예3) 문자는 UTF-8, UTF-16인지 확실히 변환하자
    * 예4) 시간표현은 가지각색이다, UTC를 이용하는 것이 가장 좋다
  * 규칙7: 코드와 데이터를 분리하기
    * 예를 들어 아래와 같은 경우이다, 코드속에 데이터가 같이 있다
    ```
    string getMonthName(int month) {
     if(month == 1) return "January";
     if(month == 2) return "Feburary";
     ...
     return "December";
    }
    ```
    * 이 때에는 자료를 분리해서 사용한다, 그래야 실수가 줄어든다
    ```
    const string monthName[] = {"January", "Feburary", ..., "December"};
    ```
## 3.3 자주하는 실수
* 산술 오버플로우
  * 매우 중요해서 3.5에서 따로 다루겠음
* 배열 범위 밖 원소에 접근
  * 배열의 size와 index를 꼭 구별해서 사용하자
  * 아래와 같이 선언해서 array[10] 에 접근하면 컴파일 에러도 안나기 때문에 디버깅하기 어려운 문제가 런타임에 발생한다
  ```
  int array[10], t;
  ```
* 일관되지 않은 범위 표현 방식 사용하기
  * 열린구간
    * (2, 10) : 3~9
  * 닫힌구간
    * [2, 10] : 2~10
  * C++을 포함하는 대부분의 프로그래밍 언어는 half-open interval 을 사용함을 기억하자
    * [2, 10) : 2~9
  * C++ STL의 iterato에서 이와 같은 방법을 사용함을 기억하자
    * list.begin() : 시작원소
    * list.end() : null 이다, list.end()-1 을 사용해야 null에 접근하지 않는다
  * 이러한 법칙에 일관성이 없으면 어떤 함수를 호출할때 전달하는 값의 범위와 함수내부에서 사용하는 범위가 달라질 수 있기 때문에 일관성을 갖자
* Off-by-one
  * 어떤 연산에서 1개 차이로 오류가 발생하는 경우를 뜻한다
  * 예를 들어 100미터 거리에 10미터마다 기둥을 세운다고 할 때 기둥의 개수는 11개이다
  * 즉, A[0] ~ A[10] 까지의 평균을 구할때는 아래와 같다
    * A[0] + A[10] / 11 (end - begin + 1)
  * 또한, A[1] ~ A[1] 까지의 평균은 아래와 같다
    * A[1] / 1 (end - begin + 1)
* 컴파일러가 잡아주지 못하는 상수 오타
  * 정말 단순한 실수가 오답으로 판정되는 경우가 즐비하다
  * 실수를 줄이는 것이 중요하다
  * 예1) weird 를 wierd 로 쓴 경우
  * 예2) 1000000000 <- 0의 개수를 틀리는 경우
  * 예3) C++에서 64비트는 상수 뒤에 LL을 붙여야 하는데 붙이지 않은 경우
* 스택오버플로우
  * 프로그래밍 대회에서는 재귀함수도 자주 사용하기 때문에 유의할 필요가 있다
  * C++의 경우, 배열이나 클래스를 지역변수로 선언하면 스택을 사용한다
  * 따라서 기본적으로 힙을 사용하게 되는 STL컨테이너를 사용하는 것이 더 좋은 방법이다
* 다차원 배열 인덱스 순서 바꿔쓰기
  * 실무에서는 2차원 배열보다 차수가 큰 배열을 사용하는 경우가 드물지만 프로그래밍 대회에서는 이런 상황이 종종 발생한다
  * 이것을 헷갈리지 말아야 하며 8장의 메모이제이션 부분을 설명할때 상세히 배운다
* 잘못된 비교함수 작성
  * C++ < 연산자의 성질
    * a<a는 항상 거짓입니다, 이 성질을 비반사성이라고 합니다
    * a<b가 참이면 b<a는 거짓입니다, 이 성질을 비대칭성이라고 합니다
    * a<b가 참이고 b<c가 참이면 a<c 입니다, 이 성질을 전이성이라고 합니다
    * a<b와 b<a가 모두 거짓이면 a와b는 같은 값으로 간주합니다, a와b가 같고, b와c가 같다면 a와c도 같아야 합니다
    이 성질을 상등관계의 전이성이라고 합니다
  * 위의 정보를 참고하여 아래와 같이 집합 비교함수를 overloading 해서 C++ 표준 정렬함수(sort)에 전달하면 결과를 예측할 수 없습니다
  ```
  // 진부분집합을 판정하는 함수
  bool isProperSubset(const IntegerSet& a, const IntegerSet& b);
  
  bool operater<(const IntegerSet& a, const IntegerSet& b)
  {
    if(isProperSubset(a,b))
      return true;
    if(isProperSubset(b,a))
      return false;
      
    return false;
  }
  ```
  * 이 때, 아래와 같은 3가지 집합을 정렬함수에 전달하면 위의 규칙에 혼란이 온다
  * {1} < {2} < {2,3} 
    * 먼저, isProperSubset 함수는 {2} < {2,3} 에 대해 true 를 반환하는데 이와 다른 결과도 아래처럼 생성된다
    * C++ < 연산자 "규칙4"에 의해 아래 2가지가 성립된다
      * {1}<{2} : 거짓 / {2}<{1} : 거짓이므로 {1} == {2}
      * {1}<{2,3} : 거짓 / {2,3}<{1} : 거짓이므로 {1} == {2,3}
      * 따라서, {1} == {2} == {2,3} 가 되고 {2} < {2,3} 과 충돌이 남
  * 그러므로 아래와 같이 구현해야 한다
  ```
  bool operator<(const IntegerSet& a, const IntegerSet& b)
  {
    if(a.size() != b.size()) 
      return a.size() < b.size();
    
    return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
  }
  ```
* 최대,최소 예외 잘못 다루기
  * 최대,최소값(즉, 경계값)에 대한 오류만 확인해도 많은 문제를 사전에 예방할 수 있습니다
  * 예를 들어, 아래코드는 소수를 구별하는 코드인데 최소값 문제가 있습니다
  ```
  bool isPrime(int n)
  {
    if(n % 2 == 0)
      return false;
    
    for(int i =2; i<n; ++i)
      if(n % i == 0)
        return false;
        
    return true;
  }
  ```
  * 문제점
    * 2는 짝수이지만 소수이며
    * 1은 소수가 아님에도 true를 리턴
* 연산자 우선순위 잘못 쓰기
  * if (b & 1 == 0) 은 항상 거짓임
  * if ((b & 1) == 0) 과 같이 우선순위가 확실하지 않을때는 항상 괄호를 써줘야 함
* 너무 느린 입출력 방식 선택
  * 프로그래밍 대회에서는 입력자료가 10000개~ 도 넘어가는 경우가 더러 있음
  * 이럴 때에 시간초과로 오답처리 되는 경우도 있음
  * C++ 에서 지원하는 입력함수 gets() , cin 중 gets() 가 성능면에서 훨씬 좋음
  * cin을 사용하기 전에 동기화를 끄는 방법도 있음 : cin.sync_with_stdio(false);
* 변수 초기화 문제
  * 많은 프로그래밍 대회에서는 여러벌의 데이터를 주고 반복해서 답을 처리하는 경우가 많음
  * 1벌의 데이터를 처리하고 나서는 꼭 초기화를 해줘야 함
  * 초기화를 항상 하는 것이 가장 좋은 방법이며, 아래와 같은 방법으로 테스트하는 것도 도움이 됨
  * 입력데이터를 복사해서 2배로 늘림 (작은 데이터처리 후에 큰 데이터 처리할 때 문제가 생기는 경우 및 반대의 경우를 걸러줌)
  ```
  2
  1234
  321
  ```
  ```
  4
  1234
  321
  1234
  321
  ```
## 3.4 디버깅과 테스팅
* 디버깅 툴은 매우 유용한 도구이지만, 프로그래밍 대회에서는 아래와 같은 이유로 눈으로 디버깅하는 경우가 많음
  * 소스코드가 길지 않아서 눈이 더 빠름
  * 재귀호출이나 중복반복문은 도구가 오히려 어려울 수 있음
  * ACM-ICPC 같은 대회는 3명이 1개의 PC를 쓰기 때문에 애초에 불가능함
* 따라서 도구없이 디버깅하는 연습이 필요하며 이러한 방법은 실제로 버그없이 구현하는데 도움을 줌
  * 오동작하는 경우를 만들어서 실행해보기
  * assert문 사용하기
  * 계산과정의 중간결과를 출력하기
* 위의 방법외에 런타임 에러 등으로 프로그램이 죽을때는 디버거를 사용하는 것이 더 좋다
* 코딩을 진행하면서 주어진 답안을 정확히 출력하는 것도 좋지만 예외 상황을 만들어서 계속해서 테스팅 하는 것이 좋다
  * 내 코드를 테스트하는 코드를 만들어 보는 것이다, 스캐폴딩이라고도 함
  * (이런 상황이 많지 않지만) 만약 정렬알고리즘을 구현한다면, STL표준 함수인 sort()와 비교해 보는 것도 방법이다
## 3.5 변수 범위의 이해
* 산술 오버플로우
