# 1징. 문제해결과 프로그래밍 대회
## 1.1 도입
* 프로그래머는 다양한 종류가 있지만, 어떤 분야를 막론하고 문제해결능력은 필수적이다
* 그러나 실무에서는 문제해결 자체보다 전체 시스템의 구조에 영향을 받는 경우가 많으므로 문제해결 능력을 기르는 것은 어렵다
* 이러한 문제해결 능력은 추상적인 기술이므로 훈련하기가 어려운데 가장 좋은 방법은 프로그래밍 대회에 자주 참가하는 것이다
## 1.2 프
* 프로그래밍 대회가 좋은 이유
  * 그래픽 인터페이스가 없으므로 문제해결에만 집중할 수 있음
  * CPU를 사용하는 계산집중적 문제이기 때문에 알고리즘과 자료구조를 직접 사용해 볼 수 있음
  * 정답과 오답의 구분이 명화가기 때문에 객관적인 평가가 가능
  * 자신이 코딩한 프로그램의 효율성을 직접 체험
  * 실무에서는 알고리즘보다 설계가 중요한 경우가 많기 때문에 그보다 작은 부분에 집중 할 수 있음
  * 대회라는 것은 곧 경쟁이지만 실패하더라도 고수의 코드를 보고 배울 수 있음
* 유명한 프로그래밍 대회
  * 한국정보올림피아드
  * [알고스팟](http:/algospot.com)
  * [ACM-ICPC](http://www.acmicpc.net)
  * [TopCoder](http://www.topcoder.com/tc)
  * 구글코드잼
  * [코드포스](http://codeforce.com)
  * [바야돌리드 대학교](http://uva.onlinejudge.org)
  * [프로젝트 오일러](http://projecteuler.net)
  * [SPOJ Online Judge](http://spoj.pl)
* 추천서적
  * Introduction to Algorithms : 전 세계 전산학과 알고리즘, 자료구조의 교과서
  * Programming Challenges : 바야돌리드 대학교의 문제와 문제풀이 일부, 좋은 입문서
  * The Art of Computer Programming : 알고리즘 부야의 가장 권이 있는 책, MMIX 어셈블리를 사용하기 때문에 진입장벽 있음
  * 프로그래밍 콘세스트 챌린징 : 일본의 프로그래밍 고수들이 쓴 책으로 실용적이고 다양한 테크닉
* 문제 - 록 페스티벌 (난이도:하, 문제ID:FESTIVAL)
  * 상황
    * 공연장을 빌려서 록 페스티발을 개최하려 함
    * 이 공연은 여러 날 동안 진행됨
    * 하루에 한 팀의 밴드가 콘스트를 함
    * 몇 개의 밴드를 섭외할지는 결정하지 않았지만, L개의 팀은 이미 섭외함
    * 따라서 페스티벌은 최소 L일 이상 지속됨
    * N일간의 공연장 대여비용을 알고 있다가 할 때, **L일 이상 연속해서 대여하는 평균비용을 최소화하려면** 어떻게 빌려야 하나?
  * 입력의 첫 줄 - 테스트 케이스의 수 C(C<=100)
  * 각 테스트케이스의 첫번째 줄
    * 공연장을 대여할 수 있는 날들의 수 N(1<=N<=1000)
    * 이미 섭외한 공연팀의 수 L(1<=L<=1000, L<=N)
  * 각 테스트케이스의 두번째 줄
    * N개의 공연장 연속적인 대여 비용
  ```
  2
  6 3
  1 2 3 1 2 3
  6 2
  1 2 3 1 2 3
  ```
  * 정답 출력
    * 첫번째 테스트케이스 : 1.75 = (1+2+3+1) / 4
    * 두번째 테스트케이스 : 1.50 = (1+2) / 2

# 2장. 문제 해결 개관
## 2.1 도입
* 무작정 문제를 많이 푼다고 좋은 것은 아님
* 자신의 문제 해결과정을 분석하는 것이 필요
* 이 장에서는 문제 해결과정을 여러 단계로 나눠보고 각 단계별로 설명
## 2.2 문제해결 과정
* 6단계
  * 1단계: 문제를 읽고 이해하기
    * 위의 예제에서 볼 수 있듯이 문제를 이해하는 것 자체가 어렵고, 초심자들은 문제를 대충 이해하는 경우가 많다
    * 문제를 대충 이해하면 나머지 5단계를 아무리 잘해도 의미가 없다
  * 2단계: 재정의와 추성화
    * 문제를 익숙한 용어로 재정의 하는 것이다
    * 문제는 대부분 현실 세계의 개념을 서술하는 것이기 때문에 이것을 컴퓨터 프로그래밍과 연결할 수 있도록 해야한다
    * 이러한 과정을 추상화라고 하며, 잘못된 추상화는 문제의 해결방법을 오히려 어렵게 만들수도 있다
  * 3단계: 전략수립
    * 여기서 문제해결을 위한 알고리즘과 자료구조를 선택한다
    * 이미 알고있는 알고리즘과 자료구조를 통해 해결할 수 있다면 베스트이지만, 그렇지 않은 경우 여기서 가장 많은 시간을 소비하게 된다
  * 4단계: 전략검증
    * 전략을 세웠다고 해서 바로 키보드를 잡으면 안 된다
    * 선택한 알고리즘과 자료구조를 통해 문제를 주어진 시간과 메모리 용량을 통해 해결할 수 있는지 검증해야 한다
    * 그렇지 않은 경우, 3단계로 돌아가서 새로운 계획을 세운다
    * 4,5장에서는 이러한 알고리즘의 효율성과 정당성을 증명하는 전략을 배운다
  * 5단계: 전략수행(코딩)
    * 실제로 프로그래밍을 시작한다
    * 아무리 좋은 알고리즘과 자료구조를 찾았다고 해도 이를 구현할 수 없으면 아무런 의미가 없다
  * 6단계: 회고하기
    * 문제해결에 직접적인 연관은 없지만, 장기적으로 중요하다
    * 내가 해결한 과정을 돌아봐야만 유사한 문제에 대해 더 효율적인 알고리즘을 선택할 수 있다
    * 가장 좋은 방법은 문제를 해결한 코드와 접근방식을 기록으로 남겨두는 것이다
    * 맞추지 못한 경우, 오답원인도 꼭 기록해야 한다
    * 마지막으로 같은 문제를 해결한 다른사람의 코드를 봐야한다, 이를 통해 자신이 생각하지 못했던 통찰을 얻을 수 있다
    * 그래서 스터디나 인터넷을 통해 함께 공부하는 것이 중요하다
* 위의 6단계는 꼭 의식하지 않더라도 많은 문제를 풀다보면 자연스럽게 체득화 되며, 많은 프로그래밍 참가자들이 거쳐가는 과정이다
* 해결방법을 찾지 못했을 때
  * 위의 6단계를 통해서 문제를 풀지 못하는 경우가 있을 것이다
  * 물론 최대한 직접 고민하여 해결방법을 찾는 것이 중요하다
  * 다만, 너무 많은 시간을 허비하는 것도 좋지는 않으며 그럴 때는 다른 사람의 소스코드나 풀이를 참고한다
  * 단, 자신이 왜 그러한 풀이를 떠올리지 못했는지 돌아봐야 하며 해당 알고리즘, 자료구조, 풀이기법을 꼭 기록하자
  * 그래야만 유사한 문제를 봤을 때, 해당 기법이 떠오를 것이다
## 2.3 문제해결 전략
* 전략수립을 위한 체계적인 접근방법 10가지
  * 전략수립이 막막한 경우가 많다
  * 이럴때는 문제해결을 위한 직관력을 키우는게 중요한데, 처음부터 직관력을 가질수는 없다
  * 직관력은 아래와 같은 방법을 통해 많은 문제를 해결하다 보면 발달하게 되며 아래 10가지는 이를 위한 좋은 시작점이다
    * 4-1단계: 비슷한 유형 떠올려보기
      * 어떤 문제의 유형에는 어떤 알고리즘을 사용한다라는 것이 연상되는 경우이다
      * 이를 위해서는 문제가 어떤 유형이고 이를 위한 해결법이 무엇인지를 체계적으로 공부해야 한다 이 책은 이러한 방법을 도와준다
      * (예) 문제유형-경우의 수, 해결법-동적계획법 / 문제유형-두 도시를 잇는 가장빠른 기차, 해결법-최단경로 알고리즘
    * 4-2단계: 단순한 방법으로 시작해보기
    * 4-3단계: 손으로 해보기
    * 4-4단계: 단순화하기
    * 4-5단계: 그림 그려보기
    * 4-6단계: 수식화해보기
    * 4-7단계: 분해해보기
    * 4-8단계: 뒤에서부터 생각하기
    * 4-9단계: 순서를 강제로 만들기
    * 4-10단계: 정규화된 답을 찾기

# 3장. 코딩과 디버깅에 관하여
## 3.1 도입: 코딩의 중요성을 간과하지 말라
* 2장에서 문제해결을 전략을 주로 다뤘으며 그 중에서 5단계: 전략수행(코딩) 은 역시 중요하다
* 문제해결만 된다면 스파게티 코드를 작성해도 되는 것이 아니다
* 코드가 간결하고 이해하기 쉬워야만 문제해결 과정에서 디버깅이 쉽고 실수를 줄일 수 있다
## 3.2 좋은 코드를 짜기 위한 원칙
* 좋은 코딩습관을 위한 규칙들은 아래와 같다
  * 규칙1: 간결한 코드를 작성하기
  * 규칙2: 적극적으로 코드 재사용하기
  * 규칙3: 표준 라이브러리 공부하기
  * 규칙4: 항상 같은 형태로 프로그램을 작성하기
  * 규칙5: 일관적이고 명로한 명명법 사용하기
  * 규칙6: 모든 자료를 정규화해서 저장하기
  * 규칙7: 코드와 데이터를 분리하기
* 각각에 대한 상세설명
  * 규칙1: 간결한 코드를 작성하기
    * 어떤 프로그래밍을 하더라도 주요한 원칙 중 하나이다
    * 프로그래밍 대회에서의 특징이라면 전역변수와 매크로를 사용하는 것도 어느정도 필요하다는 것이다
    * 왜냐하면 대부분의 경우, 코드의 길이가 길지 않고, 실수를 줄이는 것이 더 중요하기 때문이다
  * 규칙2: 적극적으로 코드 재사용하기
    * 이것도 어떤 프로그래밍을 하더라도 주요한 원칙 중 하나이다
    * 프로그래밍 대회에서의 특징이라면 SRP(Single Response Principle)이 적용되지 않는 경우가 많다
    * 실무에서는 한개의 클래스 또는 함수가 하나의 역할만 하도록 설계,구현하는 것이 일반적이지만,
    * 프로그래밍 대회에서는 그렇게 하면 시간제한도 있고, 재사용하기 어려운 경우가 많기 때문에 SRP는 일반적이지 않다
  * 규칙3: 표준 라이브러리 공부하기
    * 학교에서 숙제를 하듯이, 이미 구현된 알고리즘, 자료구조를 직접 구현하는 것은 낭비이다
    * 문자열, 동적배열, 스택, 큐, 리스트, 사전 등의 자료구조와 정령 등의 표준알고리즘, 즉 C++ STL 사용법을 반드시 알아두어야 한다
  * 규칙4: 항상 같은 형태로 프로그램을 작성하기
    * 프로그래밍 습관이 들쭉날쭉하면 실수하기 쉽고 디버깅에 긴 시간을 들이게 된다
    * 예를 들어, while/do-while 중 어떤것을 사용할지, 2차원 배열을 크기를 가로/세로 혹은 세로/가로 순서로 전달하는지 등은 일관성이 있어야 한다
  * 규칙5: 일관적이고 명료한 명명법 사용하기
    * 프로그래밍 대회의 경우, 실무적인 코딩과 다른 부분이 많지만 이것은 동일하게 적용된다
    * 예를 들어, 아래와 같은 함수는 무언가를 평가하는 것인데 어느경우에 참인지 알 수가 없다
    ```
    bool judge(int y, int x, int cy, int cx, int cr);
    ```
    * 아래와 같이 명명해야 실수하지 않는다
    ```
    bool isInsideCircle(int y, int x, int cy, int cx, int cr)
    ```
  * 규칙6: 모든 자료를 정규화해서 저장하기
    * 정규화는 어떤 자료를 입력받자마자 바로 수행해야 한다
    * 여기서 정규화라는 것은 아래와 같은 경우를 의미한다
    * 예1) 9/6 과 3/2 는 같은 값이므로 1가지로 통일하자
    * 예2) 2차원 평면에서 두 점의 각도를 구한다고 하면 -30도, 330도, 690도는 같은 값이므로 1가지로 통일하자
    * 예3) 문자는 UTF-8, UTF-16인지 확실히 변환하자
    * 예4) 시간표현은 가지각색이다, UTC를 이용하는 것이 가장 좋다
  * 규칙7: 코드와 데이터를 분리하기
    * 예를 들어 아래와 같은 경우이다, 코드속에 데이터가 같이 있다
    ```
    string getMonthName(int month) {
     if(month == 1) return "January";
     if(month == 2) return "Feburary";
     ...
     return "December";
    }
    ```
    * 이 때에는 자료를 분리해서 사용한다, 그래야 실수가 줄어든다
    ```
    const string monthName[] = {"January", "Feburary", ..., "December"};
    ```
## 3.3 자주하는 실수
    
  
  
   
