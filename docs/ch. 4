4장
알고리즘 : 컴퓨터가 작업을 해결하는 방법
Q) 어떤 프로그래밍 대회에서 N명의 사람들이 참가했다. 채점을 마친 뒤 1등부터 20등까지 평균을 내고 싶다.
A1) 내림차순 정렬 -> 20등까지 평균
A2) 별도의 20개짜리 배열을 하나 생성하고 N명의 점수를 루프를 돌면서 배열에 계속 끼워넣는다. 
A3) 한 명의 점수를 기준으로 삼아 기준 이상/기준 이하 두 그룹으로 나눈 뒤 기준 이상 그룹이 20명 이상이면 거기서 다시 기준 정하기/ 20명 이하면 하위 그룹에서 다시 정하기

-> 즉 같은 일을 하지만 여러가지 방법은 존재한다.
-> 그럼 여러가지 방법 중에 best를 판단하는 방법은 무엇인가?
결국 시간(=수행속도)과 공간(=메모리)
그런데 시간과 공간은 결국 상충한다. 메모리 많이 쓰면 시간은 단축, 메모리 적게 쓰면 시간은 오래오래.
-> 우리는 프로그래밍 대회에 참여! 정해진 시간 안에 결과만 나온다면 길이/메모리는 상관이 없다.

4.1. 도입
알고리즘의 시간은 어떻게 측정할 것인가?
바로 반복문!
반복문은 입력의 크기에 따라 수행횟수가 정해진다. 입력이 많으면 수행횟수가 증가한다.

N개의 크기를 가진 배열이 있다. 이 배열에서 가장 많이 등장하는 수를 찾자!
코드 4.1 이 for문을 중첩으로 쓰는 case -> for문 이중으로 쓰면 N^2
코드 4.2 는 count를 저장하는 배열을 생성해서 for문을 한 번만 돌자.

그래서 우리가 살펴볼 것은 알고리즘 수행시간에 따른 효율성 분석

4.2 선형 시간 알고리즘
Q) 매 달 몸무게를 측정/기록한다. 지난 3달 간의 평균을 측정한다. (=이동평균)
코드 4.3의 방법은 i가 2번 째부터 시작해서 하나씩 증가하면서 평균 계산 -> 수행 시간이 N*M - M^2 +M -> 제곱이다
코드 4.4의 방법은 중복을 찾은 것. 앞의 평균과 뒤의 평균에서 결국 0번 째와 M번 째의 차이가 있다.
예를 들어 0, 1, 2, -> 1, 2, 3  중복은 1, 2다. 그래서 0, 1 더해놓고 2 더한 다음에 평균 계산, 그리고 0 뻰다. 그 다음 루프에서는 3 더해서 평균 계산.
-> 수행 시간은 N 이다.
-> 입력의 갯수와 수행 시간이 선형이다.!

4.3. 선형 이하 시간 알고리즘
Q) 연예인의 성현 시점을 찾자. 10 만 장의 사진 중에서.. 특정 시점이다. (=이진탐색)
5만 번째 사진을 본다 -> 성형 했니? 안 했니? -> 그럼 그 시점 before/after가 정해진다.
7만 5천번째 사진을 보자 -> 성형 했니? 안 했니?

요런 식으로 줄이면 17번이면 끝
2^17 > 10만

입력이 10만 인데...입력보다 적은 횟수 17번만에 찾았다.
-> 생각은 간단하지만 구현은 어렵다.

4.4 지수 시간 알고리즘
# 다항 시간 알고리즘
 다항식? 변수 N, N^2, N의 거듭제곱들의 선형 결합
 -> 앞에서 말한 거 다 다항 시간 알고리즘이다. 
 
# 지수 시간 알고리즘
Q)  N명의 미쓰에이가 집들이를 온다. 혁님은 6개의 메뉴를 할 줄 안다. 근데 미쓰에이가 음식 알러지가 있어서 먹을 수 있는 메뉴가 다 다르다.
혁님은 마음으로는 6개 메뉴(=M개)를 다 준비하고 싶지만 현실적인 이유로 N명의 미쓰에이 친구들한테 최소한으로 모두가 먹을 수 있는 집들이를 준비할려고 한다.

6개의 음식 가지고 만들 수 있는 조합의 갯수는? 2^6
코드 4.5 재귀함수를 이용합니다.
여기서 menu는 혁님이 최종적으로 만들 음식 배열, food는 대상이 되는 음식
food+1을 넣는 이유는 현재 대상이 되는 food는 안 만들 거니까 다음 음식으로 넘겨버리는 거
그 다음에 대상이 되는 음식을 menu에 넣고 min 값 비교

결국 혁님이 만들 줄 아는 음식이 많으면 exponential 하게 증가한다는 이야기 -> 다항 시간과는 비교도 안 되게 빠르게 증가한다.

-> 우리는 계속 입력의 갯수만 신경썼는데..입력은 한 개지만 그 입력의 크기가 어마무시하다면? 
Q) 소인수 분해
코드 4.6은 N이 1이 될 때까지 for문을 돌면서 계속 나누자.
최악의 경우는 소수이다. -> 수행 시간이  N-1 (소수인데..이게 맞는건가?)
또 다른 관점에서 보면 입력의 값이 커지면 숫자를 저장하는 메모리 공간 증가-> 비트비트 -> 비트 하나 증가할 때마다..두 배로..-> 결국 입력 크게에 따라 지수 시간으로 증가합니다.

4.5 시간 복잡도
알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것
-> 어떤 프로그램이 실행되는 동안 N개의 입력을 이용하여 수행되는 기본적인 연산의 수 -> 그게 f(N)
f(N) = xN + y  

그림 4.3은 시간 복잡도가 낮다고 해서 더 빠르게 동작하지 않는다는 예..N이 60 이하 일 때는 B 알고리즘이 좋다
-> 그래서 시간복잡도가 큰 의미를 갖지 못 한다.

입력의 크기도 의미가 없다.
코드 4.7은 배열에서 주어진 숫자 찾아서 위치 반환하는 문제이다.
주어진 숫자가 나이스하게 앞 쪽에 위치할 수도 있고..재수없게 뒤에 있을 수도 있다.
그래서 
최선
최악
평균을 계산한다.

점근적 시간표기: O표기
Big-O Notation: 주어진 함수에서 가장 빨리 증가하는 항만 남긴 채 나머지 다 버려!
